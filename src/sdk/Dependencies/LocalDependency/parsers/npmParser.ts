import path from "path";
import { PackageURL } from "packageurl-js";
import { ILocalDependency } from "../DependencyTypes";

const PURL_TYPE = "npm";


// Parse a package.json file from node projects
// See reference on: https://docs.npmjs.com/cli/v8/configuring-npm/package-json
const MANIFEST_FILE = "package.json";

/**
 * Extracts namespace and name from dependency
 * @param {string} dep - dependency
 * @returns {Object} Object containing namespace and name properties
 */
function getNameAndNameSpaceFromDep(dep:string):{namespace:string, packageName:string} {
  const parts = dep.split('/');
  const namespace = parts.length > 1 ? parts[0] : undefined;
  const packageName = parts.length > 1 ? parts[1] : parts[0];
  return { namespace, packageName };
}


export function packageParser(fileContent: string, filePath: string): Promise<ILocalDependency> {
  // If the file is not manifest file, return an empty results
  const results: ILocalDependency = { file: filePath, purls: [] };
  if (path.basename(filePath) != MANIFEST_FILE)
    return Promise.resolve(results);

  const o = JSON.parse(fileContent);
  let devDeps = Object.keys(o.devDependencies || {});
  let deps = Object.keys(o.dependencies || {});

  for (const name of deps) {
    const { namespace , packageName } = getNameAndNameSpaceFromDep(name);
    const purlString = new PackageURL(PURL_TYPE, namespace, packageName, undefined ,undefined, undefined).toString();
    results.purls.push({ purl: purlString, scope: "dependencies", requirement: o.dependencies[name] });
  }

  for (const name of devDeps) {
    const { namespace , packageName } = getNameAndNameSpaceFromDep(name);
    const purlString = new PackageURL(PURL_TYPE, namespace, packageName, undefined ,undefined, undefined).toString();
    results.purls.push({ purl: purlString, scope: "devDependencies", requirement: o.devDependencies[name] });
  }

  return Promise.resolve(results);
}


// Parse a package-lock.json file from node projects
// See reference on: https://docs.npmjs.com/cli/v8/configuring-npm/package-json

const dRegex = new RegExp(/.*node_modules\/((?<scope>@.*)\/)?(?<p_name>.*)$/);

export function packagelockParser(fileContent: string, filePath: string): Promise<ILocalDependency> {

  const results: ILocalDependency = { file: filePath, purls: [] };

  if (path.basename(filePath) != "package-lock.json")
    return Promise.resolve(results);

  const packages = JSON.parse(fileContent)?.packages;

  if (!packages) return Promise.resolve(results);

  for (const [key, value] of Object.entries(packages)) {
    if (!key) continue;

    const dep = key.match(dRegex);

    let purl = new PackageURL(PURL_TYPE, dep.groups.scope, dep.groups.p_name, undefined, undefined, undefined).toString();
    let req = value["version"];
    results.purls.push({ purl: purl, requirement: req });
  }

  return Promise.resolve(results);
}


export function yarnLockParser(fileContent: string, filePath: string): Promise<ILocalDependency> {
  const results: ILocalDependency = { file: filePath, purls: [] };

  if (path.basename(filePath) != "yarn.lock")
    return Promise.resolve(results);

  const yarnVersion = yarnLockRecognizeVersion(fileContent);
  if (yarnVersion === YarnLockVersionEnum.V1) return yarnLockV1Parser(fileContent, filePath);
  else if (yarnVersion === YarnLockVersionEnum.V2) return yarnLockV2Parser(fileContent, filePath);

  return Promise.resolve(results);
}

enum YarnLockVersionEnum {
  "V1",
  "V2",
  UnknownYarnLockFormat
}

/*
    The start of v1 file has this:
        # THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
        # yarn lockfile v1

    The start of v2 file has this:
        # This file is generated by running "yarn install" inside your project.
        # Manual changes might be lost - proceed with caution!

        __metadata:
 */
export function yarnLockRecognizeVersion(fileContent: string): YarnLockVersionEnum {

  const yarn = fileContent.split("\n", 10); //Check only the first 10 lines;
  for (const line of yarn) {
    if (line.includes("__metadata:")) return YarnLockVersionEnum.V2;
    if (line.includes("yarn lockfile v1")) return YarnLockVersionEnum.V1;
  }
  return YarnLockVersionEnum.UnknownYarnLockFormat;
}

export function yarnLockV1Parser(fileContent: string, filePath: string): Promise<ILocalDependency> {

  const results: ILocalDependency = { file: filePath, purls: [] };

  //Yield an array with each element is a dependency
  /*
    "@babel/core@^7.1.0", "@babel/core@^7.3.4":
      version "7.3.4"
      resolved "https://registry.yarnpkg.com/@babel/core/-/core-7.3.4.tgz#921a5a13746c21e32445bf0798680e9d11a6530b"
      integrity sha512-jRsuseXBo9pN197KnDwhhaaBzyZr2oIcLHHTt2oDdQrej5Qp57dCCJafWx5ivU8/alEYDpssYqv1MUqcxwQlrA==
      dependencies:
        "@babel/code-frame" "^7.0.0"
        "@babel/generator" "^7.3.4"
   */
  const yl_dependencies = fileContent.split("\n\n");

  for (const yl_dependency of yl_dependencies) {


    const dependencyData: Record<string, string> = {};
    const topRequirements = [];

    const dep_lines = yl_dependency.split("\n");
    if (dep_lines.every((line) => line.trim().startsWith("#") == true)) continue; //All lines are coments
    if (dep_lines.every((line) => line.trim() == "")) continue;  //All lines are empty lines

    for (const dep_line of dep_lines) {

      // Clean comments and empty lines
      const trimmed = dep_line.trim();
      const comment = trimmed.startsWith("#");
      if (!trimmed || comment) continue;

      // Do nothing with it's own dependencies
      //    "@babel/code-frame" "^7.0.0"
      //    "@babel/generator" "^7.3.4"
      if (dep_line.startsWith(" ".repeat(4))) {
      }

        //  version "7.3.4"
        //  resolved "https://registry.yarnpkg.com/@babel/core/-/core-7.3.4.tgz#921a5a13746c21e32445bf0798680e9d11a6530b"
        //  integrity sha512-jRsuseXBo9pN197KnDwhhaaBzyZr2oIcLHHTt2oDdQrej5Qp57dCCJafWx5ivU8/alEYDpssYqv1MUqcxwQlrA==
      //  dependencies:
      else if (dep_line.startsWith(" ".repeat(2))) {
        const dep = trimmed.split(" ");
        const key = dep[0].trim();
        if (key !== "dependencies:" && key !== "optionalDependencies:") {
          dependencyData[key] = dep[1].replace(/\"|\'/g, "");
        }
      }

        // the first line of a dependency has the name and requirements
      //"@babel/core@^7.1.0", "@babel/core@^7.3.4":
      else if (!dep_line.startsWith(" ")) {
        const dep = dep_line.replace(/:/g, "").split(",");
        const requirements = dep.map(line => line.trim().replace(/"|'/g, ""));

        for (const req of requirements) {

          const atIndex = req.lastIndexOf("@");

          let constraint = req.slice(atIndex + 1);  // gets ^7.1.0
          constraint = constraint.replace(/"|'/g, "");

          const ns_name = req.slice(0, atIndex);

          let ns = "";
          let name = ns_name;
          if (ns_name.includes("/")) {
            const slashIndex = req.lastIndexOf("/");
            ns = ns_name.slice(0, slashIndex);
            name = ns_name.slice(slashIndex + 1);
          }

          topRequirements.push({ constraint: constraint, ns: ns, name: name });
        }

      }


    }

    //Make sure that name and namespace are equal for the same dependency
    const isNsNameEqual = topRequirements.every((topRequirement) => {
      return topRequirement.ns === topRequirements[0].ns && topRequirement.name === topRequirements[0].name;
    });

    if (!isNsNameEqual) {
      console.error("Different names for same dependency is not supported");
      continue;
    }
    const topRequirement = topRequirements[0];
    const namespace = topRequirement.ns;
    const name = topRequirement.name;
    const version = dependencyData["version"];
    const purl = new PackageURL(PURL_TYPE, namespace, name, version, undefined, undefined).toString();

    let requirement = "";
    for (const topRequirement of topRequirements) {
      requirement += topRequirement.constraint + ", ";
    }
    if (requirement.endsWith(", ")) {
      requirement = requirement.slice(0, requirement.length - 2);
    }

    results.purls.push({ purl: purl, requirement: requirement });

  }


  return Promise.resolve(results);

}


//TODO: Implement yarn lock V2 parser
export function yarnLockV2Parser(fileContent: string, filePath: string): Promise<ILocalDependency> {

  const results: ILocalDependency = { file: filePath, purls: [] };


  return Promise.resolve(results);

}
