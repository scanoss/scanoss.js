import { VulnerabilityCfg } from "./VulnerabilityCfg";
import { VulnerabilityHttpClient } from "../Clients/Vulnerability/VulnerabilityHttpClient";
import { logger } from "../Logger";
import { chunkRequest } from "../Clients/helper/clientHelper";
import {
  ComponentsVulnerabilitiesResponse,
  ComponentVulnerability,
  ComponentVulnerabilityResponse
} from "../types/vulnerability/types";
import { Component } from "../types/common/types";
import { ClientConfig } from "../Clients/interfaces/ClientConfig";

export class VulnerabilityScanner {
  private config: VulnerabilityCfg;

  private vulnerabilityClient: VulnerabilityHttpClient;

  constructor(config?: VulnerabilityCfg) {
    if (config) this.config = config;
    else this.config = new VulnerabilityCfg();
    const clientCfg: ClientConfig = {
      API_KEY: this.config.API_KEY,
      HTTP_PROXY: this.config.HTTP_PROXY,
      HTTPS_PROXY: this.config.HTTPS_PROXY,
      NO_PROXY: this.config.NO_PROXY,
      CA_CERT: this.config.CA_CERT,
      IGNORE_CERT_ERRORS: this.config.IGNORE_CERT_ERRORS,
      HOST_URL: this.config.API_URL, // Only map the one that differs. TODO: Migrate to HOST URL on v1 version
    };
    this.vulnerabilityClient = new VulnerabilityHttpClient(clientCfg);
  }

  public async getVulnerabilitiesComponents(components: Array<Component>): Promise<ComponentsVulnerabilitiesResponse>{
    const requests = chunkRequest(components, this.config.REQUEST_CHUNK_SIZE);
    const response: ComponentsVulnerabilitiesResponse = {
      components: [],
      status:{
        status: "SUCCESS",
        message: "Vulnerabilities retrieved successfully"
      }
    };
    const failedRequests= [];
    const componentVulnerabilities = new Map<string, ComponentVulnerability>();
    for (const request of requests) {
      try {
        const r = await this.vulnerabilityClient.getVulnerabilitiesComponents(request)
        if (r.components) {
          for(const c of r.components){
            const key = c.purl + c.requirement + c.version;
            if (componentVulnerabilities.has(key)) {
              componentVulnerabilities.get(key).vulnerabilities.push(...c.vulnerabilities);
            } else {
              componentVulnerabilities.set(key, c);
            }
          }
        }
      } catch (error) {
        failedRequests.push(request);
        logger.error(error);
      }
    }

    if (failedRequests.length > 0) {
      if (failedRequests.length >= requests.length) {
        response.status.status = "FAILED";
        response.status.message = "Error while retrieving vulnerabilities";
        return response;
      } else {
        response.status.status = "SUCCEEDED_WITH_WARNINGS";
        response.status.message = `Warning: some vulnerabilities were not retrieved: ${failedRequests.map(r => r.map((c: Component) => `${c.purl}${c.requirement}`)).join(", ")}`;
        return response;
      }
    }
    response.components = Array.from(componentVulnerabilities.values());
    return response;
  }

  public async getVulnerabilitiesComponent(component: Component): Promise<ComponentVulnerabilityResponse>{
    const response: ComponentVulnerabilityResponse = {
      purl: component.purl,
      version: component.requirement,
      requirement: component.requirement,
      vulnerabilities: [],
      status: {
        status: "SUCCESS",
        message: "Vulnerabilities retrieved successfully"
      }
    };
    try {
      const componentVulnerabilities = await this.vulnerabilityClient.getVulnerabilitiesComponent(component);
      response.vulnerabilities = componentVulnerabilities.vulnerabilities;
      response.version = componentVulnerabilities.version;
      return response;
    } catch (error) {
      logger.error(error);
      response.status.status = "FAILED";
      response.status.message = "Error while retrieving vulnerabilities";
      return response;
    }
  }
}
